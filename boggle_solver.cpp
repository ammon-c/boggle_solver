//-------------------------------------------------------------------
//
// boggle_solver.cpp
//
// C++ program to find all words in a randomly generated Boggle
// word puzzle.  An optional randomizer seed value may be given on
// the program command line to select a different random puzzle.
// The program output is printed to the console (stdout).
//
// NOTES:
//
// A Boggle game board is a 4 x 4 grid of random letters.
// For example:
//
//       T D C B
//       I K K L
//       P G E F
//       A N O M
//
// In the classic tabletop Boggle game, the random letters
// are generated by throwing a set of sixteen dice (each
// with six possible letters) onto the game board.  For
// this simplified software implementation, each cell on
// the board will contain any of the 26 possible letters.
//
// The object of a Boggle game is to find as many English
// words as possible in the grid of letters.
//
// Rules for Boggle words:
//
// * A word must be at least 3 letters in length, and no
//   longer than 17 letters in length.
//
// * A word may begin on any cell of the 4x4 grid, but each
//   successive letter must be in a cell that is a horizontal,
//   vertical, or diagonal neighbor of the prior letter.
//
// * No cell on the board may be used more than once in the
//   same word.
//
// Additional Reference Material:
//
// * https://en.wikipedia.org/wiki/Boggle
//
// To Do:
//
// This could be made to run significantly faster if the
// dictionary was restructured into a word tree where each
// node is a letter that links to the possible next letters
// of each valid word (e.g. up to 26 links per node, one for
// each letter in the alphabet).  This would allow the code
// to check if a given word prefix has any valid words, to
// avoid having to check each potential word individually. 
//
//-------------------------------------------------------------------
//
// (C) Copyright 2019 Ammon R. Campbell.
//
// I wrote this code for use in my own educational and experimental
// programs, but you may also freely use it in yours as long as you
// abide by the following terms and conditions:
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//   * Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//   * Redistributions in binary form must reproduce the above
//     copyright notice, this list of conditions and the following
//     disclaimer in the documentation and/or other materials
//     provided with the distribution.
//   * The name(s) of the author(s) and contributors (if any) may not
//     be used to endorse or promote products derived from this
//     software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
// CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR
// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
// OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
// USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
// DAMAGE.  IN OTHER WORDS, USE AT YOUR OWN RISK, NOT OURS.  
//
//-------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string>
#include <cstring>
#include <vector>
#ifdef _MSC_VER
# include <windows.h> // So we can use GetTickCount64() on Windows.
#endif

const int BOARD_WIDTH  = 4;
const int BOARD_HEIGHT = 4;
const int MIN_WORD_LENGTH = 3;
const int MAX_WORD_LENGTH = 17;
const char *DICTIONARY_FILENAME = "dictionary.asc";

// Dictionary class for doing word lookups on a pre-sorted list
// of English words.  The dictionary file is assumed to contain
// a list of common English words separated by whitespace, and
// the words in the file are assumed to be pre-sorted in
// alphabetical order. 
class Dictionary
{
public:
    Dictionary() = default;
    ~Dictionary() = default;

    // Returns true if the given word appears in the dictionary.
    bool is_word_in_dictionary(const char *text) const
	{
		const char *whites = " \t\r\n";
	
		// Convert the word to lowercase before we compare to the word list.
		std::string aword;
		while (*text && !strchr(whites, *text))
		{
			char c = *text++;
			aword += static_cast<char>(tolower(c));
		}
	
		// Start at the beginning and end of the word list.
		// The range will be narrowed via binary search until we either find the word
		// we're looking for or the start and end positions converge with no match.
		int pos_start = 0;
		int pos_end = static_cast<int>(m_words.size());
		int pos_center = -1;
		int last_center = -1;
		while (pos_start < pos_end) {
			pos_center = pos_start + (pos_end - pos_start) / 2;
			if (pos_center == last_center)
				break;
			last_center = pos_center;
	
			// Find the start of the word at or before the center.
			int adj_center = pos_center;
			while (m_words[adj_center] && !strchr(whites, m_words[adj_center]) && adj_center >= pos_start)
				adj_center--;
			while (m_words[adj_center] && strchr(whites, m_words[adj_center]) && adj_center < pos_end)
				adj_center++;
	
			// If the word at the center is greater than the word we're looking for,
			// move the end position back.  Otherwise move the start position forward.
			int comp = strncmp(&m_words[adj_center], aword.c_str(), aword.size());
       		if (comp == 0 && (aword.size() == 1 || wcschr(L" \t\r\n", m_words[adj_center + aword.size()])))
				return true;
			else if (comp >= 0)
				pos_end = pos_center;
			else
				pos_start = pos_center;
		}
	
		// The word was not found in the dictionary.
		return false;
	}

    // Reads the list of pre-sorted dictionary words from a file.
    bool load_words_from_file(const char *filename)
	{
		// Open input file.
#ifdef _MSC_VER
		FILE *fp = nullptr;
		if (fopen_s(&fp, filename, "rb") || fp == nullptr)
#else
		FILE *fp = fopen(filename, "rb");
        if (fp == nullptr)
#endif
        {
            printf("Failed opening file '%s'\n", filename);
			return false;
        }
	
		// Determine size of file.
		if (fseek(fp, 0L, SEEK_END))
		{
			fclose(fp);
			return false;
		}
		int endpos = static_cast<int>(ftell(fp));
		if (endpos < 1)
		{
            printf("File is empty '%s' (%d)\n", filename, endpos);
			fclose(fp);
			return false;
		}
		fseek(fp, 0L, SEEK_SET);
	
		// Read contents of file.
		m_words.resize(endpos);
		if (fread(m_words.data(), 1, endpos, fp) != endpos) {
            printf("Failed reading data from file '%s'\n", filename);
			fclose(fp);
			m_words.clear();
			return false;
		}
	
		fclose(fp);
        printf("Loaded %zu bytes from '%s'\n", m_words.size(), filename);
		return true;
	}

private:
    // List of words, in alphabetical order, separated by newlines.
    std::vector<char> m_words;
};

// Data structure representing a Boggle board as a 2D array of letters.
class BoggleBoard
{
public:
    BoggleBoard()
    {
        randomize();
    }

    // Populates the Boggle board with randomly generated letters.
    // Note that this simplified implementation allows any of the 26
    // letters to appear in each cell, which doesn't strictly match the
    // classic Boggle dice game.  In classic Boggle, each cell can only
    // contain six possible letters depending on which of the Boggle dies
    // happened to land in the cell when the dice were thrown.  
    void randomize()
    {
        for (int y = 0; y < BOARD_HEIGHT; y++)
            for (int x = 0; x < BOARD_WIDTH; x++)
                cells[x][y] = (rand() % 26) + 'A';
    }

    // Prints the contents of the Boggle board to the console.
    void show() const
    {
        for (int y = 0; y < BOARD_HEIGHT; y++)
        {
            for (int x = 0; x < BOARD_WIDTH; x++)
                printf(" %c", cells[x][y]);
            printf("\n");
        }
    }

    // Searches for words on the Boggle board that start at the
    // specified cell of the board.  The list of matching words
    // is returned.
    // x is a horizontal board position from 0 to BOARD_HEIGHT - 1.
    // y is a vertical board position from 0 to BOARD_HEIGHT - 1.
    //
    std::vector<std::string> search_for_words_at_cell(int x, int y, const Dictionary &dictionary) const
    {
        std::vector<std::string> words_found;
        search_step("", 0, x, y, dictionary, words_found);
        return words_found;
    }

private:
    // The 2D grid of letters on the Boggle board.
    char cells[BOARD_WIDTH][BOARD_HEIGHT] = {0};

    // Recursive helper function called by search_for_words_at_cell.
    // Processes the specified x,y cell on the Boggle board and its
    // surrounding cells, adding any matching dictionary words to the
    // words_found list.
    //
    // On entry, word_so_far should contain the letters in the word
    // that were processed before reaching the current cell on the
    // board.
    //
    // On entry, cells_used_flags should indicates which cells on the
    // Boggle board have already been used in the current word (with
    // one bit flag per cell in row major order).
    //
    // Stops recursively processing cells when the word length
    // reaches MAX_WORD_LENGTH.
    //
    void search_step(const std::string &word_so_far,
            int cells_used_flags,
            int x, int y, const Dictionary &dictionary,
            std::vector<std::string> &words_found) const
    {
        if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT)
            return; // We hit the edge of the board.
    
        if (word_so_far.size() >= MAX_WORD_LENGTH)
        {
            // We reached the maximum allowable number of letters
            // per word, so stop searching here.
            return;
        }
    
        if (cells_used_flags & (1 << (y * BOARD_WIDTH + x)))
        {
            // This cell of the board has already been used in this word.
            return;
        }
    
        std::string word_next = word_so_far;
        word_next += cells[x][y];
        if (word_next.size() >= MIN_WORD_LENGTH && dictionary.is_word_in_dictionary(word_next.c_str()))
        {
            // We found a valid word on the Boggle board.
            words_found.push_back(word_next);
        }
    
        // A table of directional offsets to each of the 8 surrounding cells.
        const int num_directions = 8;
        const struct { int x, y; } directions[num_directions] =
        {
            { -1, -1 }, {  0, -1 }, {  1, -1 },
            { -1,  0 }, /* 0,  0 */ {  1,  0 },
            { -1,  1 }, {  0,  1 }, {  1,  1 } 
        };
    
        int cells_used_next = cells_used_flags | (1 << (y * BOARD_WIDTH + x));
    
        // Recursively process the surrounding cells on the board.
        for (int direction = 0; direction < num_directions; direction++)
        {
            int x2 = x + directions[direction].x;
            int y2 = y + directions[direction].y;
            search_step(word_next, cells_used_next, x2, y2, dictionary, words_found);
        }
    }
};

// Given a word dictionary and a Boggle board, solves the puzzle
// by finding all of the matching words on the board.  Prints each
// found word to the console, and then prints the total number of
// words that were found.
static void solve_boggle(const Dictionary &dictionary, const BoggleBoard &board)
{
    size_t total_words_found = 0;
    
    // Search for words starting at each cell of the Boggle board.
    for (int y = 0; y < BOARD_HEIGHT; y++)
    {
        for (int x = 0; x < BOARD_WIDTH; x++)
        {
            std::vector<std::string> words = board.search_for_words_at_cell(x, y, dictionary);
            if (!words.empty())
            {
               // Show the words that were found at this cell.
                printf("%zu words starting at x=%d, y=%d:\n", words.size(), x, y);
                for (auto word : words)
                    printf(" * %s (length %zu)\n", word.c_str(), word.size());
    
                total_words_found += words.size();
            }
        }
    }
    
    printf("\nTotal words found in Boggle board: %zu\n", total_words_found);
}

// Returns the system monotonic time in milliseconds.
static uint64_t clock_milliseconds()
{
#ifdef _MSC_VER
    return GetTickCount64();
#else
    struct timespec spec = {0};
    clock_gettime(CLOCK_MONOTONIC, &spec);
    return spec.tv_sec * 1000 + spec.tv_nsec / 1000000;
#endif
}

int main(int argc, char **argv)
{
    try
    {
	    // If a number was given on the command line, use it as the
        // randomizer seed, otherwise use the real time clock to set
        // the seed.
        int seed = static_cast<int>(clock_milliseconds());
	    if (argc > 1)
            seed = atoi(argv[1]);
        srand(seed);

        // Load the word dictionary into memory.	
	    Dictionary dictionary;
	    if (!dictionary.load_words_from_file(DICTIONARY_FILENAME))
	    {
	        printf("Failed reading word list from file '%s'\n", DICTIONARY_FILENAME);
	        return -1;
	    }

        // Generate a random Boggle board and show it on the console.
	    BoggleBoard board;
	    printf("\nBoggle board:\n");
        board.show();
        printf("\n");

        // Now that we're initialized, we can solve the Boggle board.
        uint64_t start_time = clock_milliseconds();
        solve_boggle(dictionary, board);
        printf("\nTime to solve:  %.2f seconds\n", (clock_milliseconds() - start_time) / 1000.0f);
    }
    catch(...)
    {
        printf("\nAborted by program exception!\n");
        return -1;
    }

    return 0;
}

